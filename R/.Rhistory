test1[10][10]
test1[10,10]
test1 = CPathena[, -c(1,2)]
test1 = log(test1 + eps)
# apply function
mads = apply(test1, 2, mad)
output = data.frame(test1)
for(i in 1:ncol(test1)) {
cat("i: ", i, "\n")
col = test1[,i]
print(length(col))
col.med = median(col)
col.mad = mads[i]
for(j in 1:nrow(test1)) {
#print(test1[[j]][[i]])
cat("j: ", j, "\n")
x = test1[j][i]
print(x)
#cat("j: ", j)
output[j][i] = (0.6745 * (x - col.med)) / col.mad
# lengt(col.mad)
}
}
test1 = CPathena[, -c(1,2)]
test1 = log(test1 + eps)
# apply function
mads = apply(test1, 2, mad)
output = data.frame(test1)
for(i in 1:ncol(test1)) {
#cat("i: ", i, "\n")
col = test1[,i]
print(length(col))
col.med = median(col)
col.mad = mads[i]
for(j in 1:nrow(test1)) {
#print(test1[[j]][[i]])
cat("j: ", j, "\n")
x = test1[j][i]
#print(x)
#cat("j: ", j)
output[j][i] = (0.6745 * (x - col.med)) / col.mad
# lengt(col.mad)
}
}
test1 = CPathena[, -c(1,2)]
test1 = log(test1 + eps)
# apply function
mads = apply(test1, 2, mad)
output = data.frame(test1)
for(i in 1:ncol(test1)) {
#cat("i: ", i, "\n")
col = test1[,i]
print(length(col))
col.med = median(col)
col.mad = mads[i]
for(j in 1:nrow(test1)) {
#print(test1[[j]][[i]])
cat("j: ", j, "\n")
x = test1[j][i]
#print(x)
#cat("j: ", j)
output[j][i] = (0.6745 * (x - col.med)) / col.mad
# lengt(col.mad)
}
}
test1 = CPathena[, -c(1,2)]
test1 = log(test1 + eps)
# apply function
mads = apply(test1, 2, mad)
output = data.frame(test1)
for(i in 1:ncol(test1)) {
cat("i: ", i, "\n")
col = test1[,i]
print(length(col))
col.med = median(col)
col.mad = mads[i]
for(j in 1:nrow(test1)) {
x = test1[j][i]
print(x)
output[j][i] = (0.6745 * (x - col.med)) / col.mad
}
}
test1 = CPathena[, -c(1,2)]
test1 = log(test1 + eps)
# apply function
mads = apply(test1, 2, mad)
output = data.frame(test1)
for(i in 1:ncol(test1)) {
col = test1[,i]
col.med = median(col)
col.mad = mads[i]
for(j in 1:nrow(test1)) {
x = test1[j][i]
output[j][i] = (0.6745 * (x - col.med)) / col.mad
}
}
test1 = CPathena[, -c(1,2)]
test1 = log(test1 + eps)
# apply function
mads = apply(test1, 2, mad)
output = data.frame(test1)
for(i in 1:ncol(test1)) {
col = test1[,i]
col.med = median(col)
col.mad = mads[i]
for(j in 1:nrow(test1)) {
x = test1[j][i]
output[j][i] = (0.6745 * (x - col.med)) / col.mad
}
}
for(i in 1:ncol(test1)) {
col = test1[,i]
col.med = median(col)
col.mad = mads[i]
print(i)
for(j in 1:nrow(test1)) {
x = test1[j][i]
output[j][i] = (0.6745 * (x - col.med)) / col.mad
}
}
test1 = CPathena[, -c(1,2)]
test1 = log(test1 + eps)
# apply function
mads = apply(test1, 2, mad)
output = data.frame(test1)
for(i in 1:ncol(test1)) {
col = test1[,i]
col.med = median(col)
col.mad = mads[i]
#print(i)
for(j in 1:nrow(test1)) {
x = test1[j][i]
print(j)
output[j][i] = (0.6745 * (x - col.med)) / col.mad
}
}
test1 = CPathena[, -c(1,2)]
test1 = log(test1 + eps)
# apply function
mads = apply(test1, 2, mad)
output = data.frame(test1)
for(i in 1:ncol(test1)) {
cat("i: ", i, "\n")
col = test1[,i]
print(length(col))
col.med = median(col)
col.mad = mads[i]
for(j in 1:nrow(test1)) {
x = test1[j][i]
print(x)
output[j][i] = (0.6745 * (x - col.med)) / col.mad
}
}
test1 = CPathena[, -c(1,2)]
test1 = log(test1 + eps)
# apply function
mads = apply(test1, 2, mad)
output = data.frame(test1)
for(i in 1:ncol(test1)) {
col = test1[,i]
col.med = median(col)
col.mad = mads[i]
for(j in 1:nrow(test1)) {
x = test1[j,i]
output[j,i] = (0.6745 * (x - col.med)) / col.mad
}
}
output
arfunction = function() {
while(TRUE) {
x = runif(1,min = -1,max = 1)
y = runif(1,min = -1, max = 1)
if (abs(x) + abs(y) <= 1){
rv = c(x, y)
return(rv)
}
}
}
samples = matrix(nrow = 3000, ncol = 2)
for(i in 1:3000) {
x = arfunction()
samples[i,1] = x[1]
samples[i,2] = x[2]
}
plot(samples[,1],samples[,2])
install.packages("rigamma")
install.packages(rigamma)
install.packages("invgamma")
library(invgamma)
?invgamma
rinvgamma(1, 2, 3)
sum(x - 3)
sum(x)
x = c(91, 504, 557, 609, 693, 727, 764, 803, 857, 929, 970, 1043, 1089, 1195, 1384, 1713)
n = length(x)
a = 3
b = 3
tau2 = 10
theta0 = 5
sum(x)
sum(x-3)
?rnorm
x = c(91, 504, 557, 609, 693, 727, 764, 803, 857, 929, 970, 1043, 1089, 1195, 1384, 1713)
n = length(x)
a = 3
b = 3
tau2 = 10
theta0 = 5
theta_mu = function(sig2) {
mu1 = (sig2 * theta0) / (sig2 + n * tau2)
mu2 = (n * tau2 * mean(x)) / (sig2 + n * tau2)
return(mu1 + mu2)
}
theta_sig = function(sig2) {
sig = (sig2 * tau2) / (sig2 + n * tau2)
return(sig)
}
gibbs <- function(s_init, theta_init, burn = 1000, nmc = 2000, alpha_0 = 2.0, beta_0 = 6.4){
theta <- rep(0, nmc+burn)
sigma2 <- rep(0, nmc+burn)
sigma2[1] = invgamma(1, (n/2) + a, 0.5 * sum((x - theta0)^(2)) + b)
theta[1] = theta0;
for (i in 2:(burn+nmc)) {
sigma2[i] <- invgamma(1, (n/2) + a, theta[i-1])
theta[i] <- rnorm(1, theta_mu(sigma2[i]), theta_sig(sigma2[i]))
}
return(list(s=s,theta=theta))
}
mcmc.fit <- gibbs(s_init, theta_init)
hist(log(mcmc.fit$sigma2[1001:2000]), breaks = 30, main="s(i) samples histogram", freq = F)
x = c(91, 504, 557, 609, 693, 727, 764, 803, 857, 929, 970, 1043, 1089, 1195, 1384, 1713)
n = length(x)
a = 3
b = 3
tau2 = 10
theta0 = 5
theta_mu = function(sig2) {
mu1 = (sig2 * theta0) / (sig2 + n * tau2)
mu2 = (n * tau2 * mean(x)) / (sig2 + n * tau2)
return(mu1 + mu2)
}
theta_sig = function(sig2) {
sig = (sig2 * tau2) / (sig2 + n * tau2)
return(sig)
}
gibbs <- function(s_init, theta_init, burn = 1000, nmc = 2000, alpha_0 = 2.0, beta_0 = 6.4){
theta <- rep(0, nmc+burn)
sigma2 <- rep(0, nmc+burn)
sigma2[1] = rinvgamma(1, (n/2) + a, 0.5 * sum((x - theta0)^(2)) + b)
theta[1] = theta0;
for (i in 2:(burn+nmc)) {
sigma2[i] <- rinvgamma(1, (n/2) + a, theta[i-1])
theta[i] <- rnorm(1, theta_mu(sigma2[i]), theta_sig(sigma2[i]))
}
return(list(s=s,theta=theta))
}
mcmc.fit <- gibbs(s_init, theta_init)
hist(log(mcmc.fit$sigma2[1001:2000]), breaks = 30, main="s(i) samples histogram", freq = F)
x = c(91, 504, 557, 609, 693, 727, 764, 803, 857, 929, 970, 1043, 1089, 1195, 1384, 1713)
n = length(x)
a = 3
b = 3
tau2 = 10
theta0 = 5
theta_mu = function(sig2) {
mu1 = (sig2 * theta0) / (sig2 + n * tau2)
mu2 = (n * tau2 * mean(x)) / (sig2 + n * tau2)
return(mu1 + mu2)
}
theta_sig = function(sig2) {
sig = (sig2 * tau2) / (sig2 + n * tau2)
return(sig)
}
gibbs <- function(burn = 1000, nmc = 2000){
theta <- rep(0, nmc+burn)
sigma2 <- rep(0, nmc+burn)
sigma2[1] = rinvgamma(1, (n/2) + a, 0.5 * sum((x - theta0)^(2)) + b)
theta[1] = theta0;
for (i in 2:(burn+nmc)) {
sigma2[i] <- rinvgamma(1, (n/2) + a, theta[i-1])
theta[i] <- rnorm(1, theta_mu(sigma2[i]), theta_sig(sigma2[i]))
}
return(list(sigma2=sigma2,theta=theta))
}
mcmc.fit <- gibbs()
hist(log(mcmc.fit$sigma2[1001:2000]), breaks = 30, main="s(i) samples histogram", freq = F)
hist(log(mcmc.fit$theta[1001:2000]), breaks = 30, main="s(i) samples histogram", freq = F)
c = 0.249999
x=0
for(i in 1:20) {
x = x^2 + c
print(x)
}
5 mod 20
5 % 20
5 %% 20
20 %% 5
c = 0.249999
x=0
for(i in 1:1000) {
x = x^2 + c
if(i %% 50 == 0) {
print(x)
}
}
c = 0.249999
x=0
for(i in 1:1000) {
x = x^2 + c
if(i %% 100 == 0) {
print(x)
}
}
c = 0.25
x=0
for(i in 1:1000) {
x = x^2 + c
if(i %% 100 == 0) {
print(x)
}
}
c = 0.250000001
x=0
for(i in 1:1000) {
x = x^2 + c
if(i %% 100 == 0) {
print(x)
}
}
c = 0.250000001
x=0
for(i in 1:100000) {
x = x^2 + c
if(i %% 100 == 0) {
print(x)
}
}
c = 0.250001
x=0
for(i in 1:1000) {
x = x^2 + c
if(i %% 100 == 0) {
print(x)
}
}
c = 0.25001
x=0
for(i in 1:1000) {
x = x^2 + c
if(i %% 100 == 0) {
print(x)
}
}
c = 0.250001
x=0
for(i in 1:10000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
c = 0.249999
x=0
for(i in 1:10000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
c = 0.25
x=0
for(i in 1:10000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
c = -1.999999
x=0
for(i in 1:10000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
c = -2
x=0
for(i in 1:10000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
c = 0.2500001
x=0
for(i in 1:10000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
c = 0.250001
x=0
for(i in 1:10000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
c = -2.000001
x=0
for(i in 1:10000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
.25/2
c = 0.124
x=0
for(i in 1:10000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
c = 0.124
x=0
for(i in 1:1000000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
c = 0.123
x=0
for(i in 1:1000000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
c = 0.1
x=0
for(i in 1:1000000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
c = 0.2
x=0
for(i in 1:1000000) {
x = x^2 + c
if(i %% 1000 == 0) {
print(x)
}
}
athena.data = read.csv("../data/UA_AthenaData.csv", header = TRUE, sep = ",")
# 6 minute timeframe
research.data = read.csv("../data/UA_ResearchData.csv", header=TRUE, sep = ",")
isLandline.data = split(research.data, research.data$isLandline)
# Split the data into groups by landline or cellphone
cellphone.data = isLandline.data$"FALSE"
landline.data = isLandline.data$"TRUE"
# aggregate the data so phone numbers are unique
CPcount = aggregate(cellphone.data$call_time ~ cellphone.data$LineNumber, cellphone.data, FUN = "length")
LLcount = aggregate(landline.data$call_time ~ landline.data$LineNumber, landline.data, FUN = "length")
## take the high-vol callers from research data and see if there are any behaviors in athena
# filter for the anomalies (more than 11 phone calls in 6 minutes)
# cut off at 0.99% (any # with calls >11 is a spam (cellphone), and >12 for landline)
CPanomaly = CPcount[CPcount$`cellphone.data$call_time` > 11,]
LLanomaly = LLcount[LLcount$`landline.data$call_time` > 12,]
# Match the phone numbers from the resarch.data with the athena data
CPathena = athena.data[CPanomaly$`cellphone.data$LineNumber`,]
LLathena = athena.data[LLanomaly$`landline.data$LineNumber`,]
# Strip off the categorial data and the cellphone numbers
cp.numeric = CPathena[, -c(1,2)]
# Compute the Median Absolute Deviation (mad)
mads = apply(cp.numeric, 2, mad)
y = names(cp.numeric[mads == 0])
# If MAD=0, then var=0, so we remove this useless feature
novariance = c()
for(i in 1:length(mads)) {
if(mads[i] == 0) {
novariance = append(novariance, i)
}
}
cp.numeric = cp.numeric[, -novariance]
mads = apply(cp.numeric, 2, mad) # Re-compute the MAD
# detect outliers using a modified-z-score approach
output = data.frame(cp.numeric) # Copy the data for rewriting
for(i in 1:ncol(cp.numeric)) {
col = cp.numeric[,i]
col.med = median(col)
col.mad = mads[i]
for(j in 1:nrow(cp.numeric)) {
x = cp.numeric[j,i]
output[j,i] = (0.6745 * (x - col.med)) / col.mad
}
}
# Remove rows that contain outliers
outliers = c()
for(i in 1:nrow(output)) {
for(j in 1:ncol(output)) {
if(abs(output[i,j] > 3.5)) {
outliers = append(outliers, i)
}
}
}
removed.outliers = output[-outliers,]
write.csv(removed.outliers, file = "test_transform1.csv", row.names = F)
